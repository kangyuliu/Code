/*
*组合
*/
/*
*给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
*/
vector<vector<int> > combine(int n, int k){
	vector<vector<int> > ret;
	if(n<=0 || k <=0 || k >n)
		return ret;
	vector<int> localRet;
	combineHelper(n, k, 1, ret, localRet);
	return ret;
}

void combineHelper(int n, int k, int pos, vector<vector<int> > &ret, vector<int> localRet){
	if(k == 0){
		ret.push_back(localRet)；
		return;
	}
	
	if(pos > n || k <0)
		return;
	
	for(int i=pos; i <=n; i++){
		localRet.push_back(i);
		if(k >0)
			combineHelper(n, k-1,i+1, ret, localRet);
		
		localRet.pop_back();
	}
	
}


/*
*组合总和 II
*/
/*
*给定一个数组 candidates 和一个目标数 target ，
*找出 candidates 中所有可以使数字和为 target 的组合。
*candidates 中的每个数字在每个组合中只能使用一次。
*说明：
*所有数字（包括目标数）都是正整数。
*解集不能包含重复的组合。 
*/

vector<vector<int> > combinationSum2(vector<int> candidates, int target){
	vector<vector<int> > ret;
	sort(candidates.begin(), candidates.end());
	vector<int> localRet;
	combinationSum2Helper(candidates, target, 0, localRet, ret);
	return ret;
}


void combinationSum2Helper(vector<int> &candidates, int target, int pos, vector<int> localRet, vector<vector<int> > &ret){
	if(target == 0){
		ret.push_back(localRet);
		return;
	}
	
	if(target <0)
		return;
	
	for(int i=pos; i < candidates.size(); i++){
		if(i > pos && candidates[i] == candidates[i-1])	//消除重复组合
			continue;
		localRet.push_back(candidates[i]);
		combinationSum2Helper(candidates, target-candidates[i], i+1, localRet, ret);
		localRet.pop_back();
	}
}

/*
*组合总和
*/
/*
*给定一个无重复元素的数组 candidates 和一个目标数 target，
*找出 candidates 中所有可以使数字和为 target 的组合。
*candidates 中的数字可以无限制重复被选取。
*说明：
*所有数字（包括 target）都是正整数。
*解集不能包含重复的组合。
*/

vector<vector<int> > combinationSum(vector<int> &candidates, int target){
	vector<vector<int> > ret;
	sort(candidates.begin(), candidates.end());
	vector<int> localRet;
	combinationSumHelper(candidates, target, 0, localRet, ret);
	return ret;
}

void combinationSumHelper(vector<int> &candidates, int target, int pos, vector<int> localRet, vector<vector<int> > ret){
	if(target == 0){
		ret.push_back(localRet);
		return;
	}
	
	if(target < 0)
		return;
	
	for(int i=pos; i < candidates.size(); i++){
		localRet.push_back(candidates[i]);
		combinationSumHelper(candidates, target-candidates[i], i, localRet, ret);
		localRet.pop_back();
	}
}